<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SPACE ATTACK - Updated</title>
<style>
  :root{ --bg:#000; --fg:#fff; --accent:#36a2ff; --good:#34d399; --warn:#f59e0b; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden;user-select:none}
  canvas{display:block;width:100vw;height:100vh;background:#000}
  .overlay{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;z-index:60;padding:18px}
  h1{font-size:clamp(2rem,6vw,3.2rem);margin:.2em 0 .35em}
  .row{display:flex;gap:12px;flex-wrap:wrap;justify-content:center}
  .btn{appearance:none;border:none;outline:none;cursor:pointer;background:linear-gradient(#222,#111); color:#fff; padding:12px 18px; border-radius:10px;font-weight:800; font-size:16px;border:2px solid rgba(255,255,255,.08)}
  .donationRow{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:12px}
  .dono{display:inline-block;padding:8px 12px;border-radius:10px;text-decoration:none;font-weight:800;border:2px solid rgba(255,255,255,.06)}
  .dono.green{background:#072b13;color:#bfffb7;border-color:rgba(66,255,144,.08)}
  .dono.blue{background:#05213d;color:#dfefff;border-color:rgba(54,162,255,.08)}
  .dono.orange{background:#3a1d00;color:#fff0d6;border-color:rgba(255,160,60,.08)}
  #hud{position:fixed;top:8px;left:8px;right:8px;display:flex;justify-content:space-between;align-items:center;font-weight:800;z-index:55;pointer-events:none}
  #hud .lives{display:flex;gap:8px;align-items:center}
  .life{width:18px;height:18px;border:2px solid var(--accent);border-radius:3px;background:#1a6fff}
  .controls{position:fixed;bottom:8px;left:8px;right:8px;pointer-events:auto;z-index:56;display:flex;justify-content:space-between;align-items:flex-end}
  .joystick{width:130px;height:130px;border-radius:50%;background:rgba(255,255,255,.02);display:flex;align-items:center;justify-content:center;touch-action:none}
  .stick{width:60px;height:60px;border-radius:50%;background:rgba(255,255,255,.06);box-shadow:0 6px 18px rgba(0,0,0,.6);transform:translate(0,0);transition:transform .02s linear}
  .firePad{display:flex;flex-direction:column;gap:10px;align-items:center}
  .fireBtn{width:84px;height:84px;border-radius:50%;background:rgba(255,255,255,.06);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:18px;touch-action:none}
  .smallBtn{width:56px;height:56px;border-radius:50%;font-size:14px}
  .toggleControls{position:fixed;top:8px;right:8px;z-index:57;background:rgba(255,255,255,.03);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,.06);cursor:pointer;font-weight:800;margin-top:12px;}
  .hint{position:fixed;left:0;right:0;bottom:10px;text-align:center;pointer-events:none;color:rgba(255,255,255,.85);font-weight:700;z-index:54}
</style>
</head>
<body>
<canvas id="cv"></canvas>

<section id="splash" class="overlay" style="background:radial-gradient(800px 400px at 50% -10%, rgba(54,162,255,.06), transparent 60%), #000;">
  <h1>SPACE ATTACK</h1>
  <div class="row" style="margin-bottom:12px">
    <button id="startBtn" class="btn">Start Game</button>
    <button id="btn-instructions" class="btn">Instructions</button>
  </div>
  <div style="opacity:.95">Tilt or drag joystick to move — Tap FIRE to shoot — Tap M for missile</div>
  <div style="margin-top:8px;opacity:.9">Comets = extra life • Pick up missiles to refill</div>
  <div class="donationRow">
    <a class="dono green" href="https://cash.app/$GrooveTime100" target="_blank" rel="noopener">CashApp $GrooveTime100</a>
    <a class="dono blue" href="https://paypal.me/GrooveTime100" target="_blank" rel="noopener">PayPal.me/GrooveTime100</a>
    <a class="dono orange" href="https://venmo.com/u/GrooveTime100" target="_blank" rel="noopener">Venmo @GrooveTime100</a>
  </div>
</section>

<div id="hud" style="display:none">
  <div class="lives" id="lives"></div>
  <div id="score">Score 0 • Level 1</div>
  <div id="ammo">Missiles 8</div>
</div>
<div id="hint" class="hint" style="display:none">Tilt enabled • Joystick overrides tilt when used</div>

<section id="gameover" class="overlay" style="display:none;background:radial-gradient(800px 400px at 50% -10%, rgba(54,162,255,.04), transparent 60%), #000;">
  <h1>Game Over</h1>
  <div id="finalScore" style="margin-bottom:12px">Score: 0</div>
  <div class="row" style="margin-bottom:12px">
    <button id="restartBtn" class="btn">Restart</button>
  </div>
  <div class="donationRow">
    <a class="dono green" href="https://cash.app/$GrooveTime100" target="_blank" rel="noopener">CashApp $GrooveTime100</a>
    <a class="dono blue" href="https://paypal.me/GrooveTime100" target="_blank" rel="noopener">PayPal.me/GrooveTime100</a>
    <a class="dono orange" href="https://venmo.com/u/GrooveTime100" target="_blank" rel="noopener">Venmo @GrooveTime100</a>
  </div>
</section>

<div id="controls" class="controls" style="display:none">
  <div class="joystick" id="joystick"><div class="stick" id="stick"></div></div>
  <div class="firePad">
    <div class="fireBtn smallBtn" id="missileBtn">M</div>
    <div class="fireBtn" id="laserBtn">FIRE</div>
  </div>
</div>

<div id="toggle" class="toggleControls" style="display:none">Controls: Tilt</div>

<script>
(() => {
  // Canvas & context
  const cv = document.getElementById('cv'), g = cv.getContext('2d');
  function fit(){ const dpr = Math.max(1, Math.min(2, devicePixelRatio || 1)); cv.width = innerWidth*dpr; cv.height = innerHeight*dpr; cv.style.width = innerWidth+'px'; cv.style.height = innerHeight+'px'; g.setTransform(dpr,0,0,dpr,0,0); }
  fit(); addEventListener('resize', fit);

  // UI refs
  const splash = document.getElementById('splash'), gameover = document.getElementById('gameover'), hud = document.getElementById('hud');
  const livesEl = document.getElementById('lives'), scoreEl = document.getElementById('score'), ammoEl = document.getElementById('ammo');
  const finalScore = document.getElementById('finalScore'), hint = document.getElementById('hint');
  const controlsEl = document.getElementById('controls'), joystickEl = document.getElementById('joystick'), stickEl = document.getElementById('stick');
  const laserBtn = document.getElementById('laserBtn'), missileBtn = document.getElementById('missileBtn'), toggle = document.getElementById('toggle');
  const startBtn = document.getElementById('startBtn'), restartBtn = document.getElementById('restartBtn'), instrBtn = document.getElementById('btn-instructions');

  // Audio
  let actx=null, master=null;
  function ensureAudio(){ if(actx) return; actx = new (window.AudioContext||window.webkitAudioContext)(); master = actx.createGain(); master.gain.value=0.9; master.connect(actx.destination); }
  function resumeAudio(){ try{ if(actx && actx.state === 'suspended') actx.resume(); }catch(e){} }
  function makeOsc(freq=440,type='sine',dur=0.1,vol=0.08){ if(!actx) return; const o=actx.createOscillator(), gn=actx.createGain(); o.type=type; o.frequency.value=freq; gn.gain.value=vol; o.connect(gn); gn.connect(master); o.start(); gn.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime+dur); o.stop(actx.currentTime+dur); }
  function makeNoiseBurst(duration=0.18, gain=0.12){ if(!actx) return; const buf = actx.createBuffer(1, actx.sampleRate*duration, actx.sampleRate); const d = buf.getChannelData(0); for(let i=0;i<d.length;i++){ d[i] = (Math.random()*2-1)*(1 - i/d.length); } const src = actx.createBufferSource(); src.buffer = buf; const gn = actx.createGain(); gn.gain.value = gain; const lp = actx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 1600; src.connect(lp); lp.connect(gn); gn.connect(master); src.start(); src.stop(actx.currentTime+duration); }
  // sfx
  function sfxStart(){ makeOsc(1000,'sine',0.06,0.06); }
  function sfxLaser(){ makeOsc(1600,'square',0.05,0.06); }
  function sfxZap(){ makeOsc(2200,'sawtooth',0.04,0.05); }
  function sfxSmallBoom(){ makeNoiseBurst(0.12,0.08); makeOsc(360,'triangle',0.08,0.04); }
  function sfxHeavyBoom(){ makeNoiseBurst(0.32,0.16); makeOsc(140,'sine',0.28,0.12); }
  function sfxOrb(){ makeOsc(420,'sine',0.09,0.04); }
  function startMusic(){ if(!actx) return; if(window.__music){ try{ window.__music.stop(); }catch(e){} window.__music = null; } const bpm=90, spb=60/bpm, beats=8, seconds=beats*spb; const buf = actx.createBuffer(1, actx.sampleRate*seconds, actx.sampleRate); const ch = buf.getChannelData(0); for(let i=0;i<ch.length;i++){ const t=i/actx.sampleRate, beat=Math.floor(t/spb); const notes=[90,120,150,180]; const n=notes[beat%4]; const env=Math.pow(1-((t%spb)/spb),2); ch[i]+= Math.sin(2*Math.PI*n*t)*0.04*env; } const src = actx.createBufferSource(); src.buffer = buf; src.loop=true; const gn = actx.createGain(); gn.gain.value = 0.06; src.connect(gn); gn.connect(master); src.start(); window.__music = src; }
  function stopMusic(){ if(window.__music){ try{ window.__music.stop(); }catch(e){} window.__music = null; } }

  // Stars (reduced count)
  const stars = [];
  function initStars(){ stars.length=0; for(let i=0;i<140;i++){ stars.push({x:Math.random()*innerWidth,y:Math.random()*innerHeight,s:0.6+Math.random()*1.8,spd:20+Math.random()*80}); } }
  initStars(); addEventListener('resize', initStars);

  // helpers
  function strokeFill(fill, stroke, w=2){ g.fillStyle=fill; g.strokeStyle=stroke; g.lineWidth=w; }
  const ri=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const nowT=()=>performance.now();
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // State
  let running=false, keys={}, last=performance.now(), frame=0;
  let player = { x: innerWidth/2, y: innerHeight-70, lasers:[], missiles:[], missileAmmo:8, cd:0, missileCd:0 };
  let score=0, lives=3;
  let enemies=[], specials=[], explosions=[], enemyShots=[], centipedes=[];
  let nextComet=0, nextMissilePickup=0, nextWave=0;
  let level=1, levelStart=performance.now();
  const LEVEL_DURATION = 30000;

  // centipede colors
  const CENT_COLORS = ['#ff3b3b','#ff943b','#ffd33b','#4cff58','#4db8ff','#bf6bff'];

  // Draw player: using earlier design but lightened
  function drawPlayer(x,y,frame){
    // exhaust flames
    const flameLen = 18 + Math.abs(Math.sin(frame*0.6))*8;
    for(let f=0; f<3; f++){
      const alpha = 0.4 - f*0.1;
      g.beginPath();
      g.fillStyle = `rgba(${255 - f*30}, ${180 - f*20}, ${40 + f*10}, ${alpha})`;
      g.moveTo(x-9, y+14);
      g.quadraticCurveTo(x, y+14+flameLen*(0.6 + Math.random()*0.4), x+9, y+14);
      g.closePath(); g.fill();
    }
    // body (lighter cyan)
    strokeFill('#bff7ff','#012',2.4);
    g.beginPath(); g.moveTo(x, y-18); g.lineTo(x+18,y+14); g.lineTo(x+6,y+12); g.lineTo(x-6,y+12); g.lineTo(x-18,y+14); g.closePath(); g.fill(); g.stroke();
    // cockpit brighter
    strokeFill('#eaffff','#013',1.4);
    g.beginPath(); g.ellipse(x,y-6,7,9,0,0,Math.PI*2); g.fill(); g.stroke();
    // fins/engines
    strokeFill('#dff','#022',1.2); g.fillRect(x-22,y+8,8,8); g.fillRect(x+14,y+8,8,8);
  }

  // Enemy drawing - distinct types
  function drawEnemy(x,y,type,elite=false,frame=0){
    if(type==='interceptor'){
      strokeFill('#cfeeff','#042',1.8);
      g.beginPath(); g.moveTo(x-18,y); g.quadraticCurveTo(x, y-22, x+18,y); g.lineTo(x+6,y+14); g.lineTo(x-6,y+14); g.closePath(); g.fill(); g.stroke();
      strokeFill('#eaffff','#033',1); g.beginPath(); g.ellipse(x,y-2,6,6,0,0,Math.PI*2); g.fill(); g.stroke();
      // cyan exhaust
      for(let i=0;i<2;i++){
        const ox=(i===0?-12:12); const len=6 + Math.abs(Math.sin(frame*0.12+i))*12;
        g.beginPath(); g.fillStyle='rgba(120,220,255,0.9)'; g.moveTo(x+ox,y+12); g.quadraticCurveTo(x+ox,y+12+len, x+ox+(i===0?-6:6), y+12); g.closePath(); g.fill();
      }
      strokeFill('#9ff','#012',1); g.fillRect(x-6,y+8,12,5);
      return;
    }
    if(type==='destroyer'){
      strokeFill('#ffd6a6','#3b1e00',2.2); g.beginPath(); g.ellipse(x,y,28,14,0,0,Math.PI*2); g.fill(); g.stroke();
      strokeFill('#fff4d9','#6b3f14',1.6); g.beginPath(); g.ellipse(x,y-6,12,8,0,0,Math.PI*2); g.fill(); g.stroke();
      strokeFill('#ff6b6b','#4a0b0b',1.6); g.fillRect(x-26,y-2,8,6); g.fillRect(x+18,y-2,8,6);
      return;
    }
    if(type==='frigate'){
      strokeFill('#7fb6ff','#062042',2.2); g.beginPath(); g.moveTo(x-20,y-8); g.lineTo(x+20,y-8); g.quadraticCurveTo(x+28,y, x+20,y+12); g.lineTo(x-20,y+12); g.quadraticCurveTo(x-28,y, x-20,y-8); g.closePath(); g.fill(); g.stroke();
      strokeFill('#dff','#01314f',1.6); g.beginPath(); g.ellipse(x,y-2,8,5,0,0,Math.PI*2); g.fill(); g.stroke();
      strokeFill('#ffb86b','#3b1a00',1.2); g.fillRect(x-18,y+8,8,6); g.fillRect(x+10,y+8,8,6);
      return;
    }
    if(type==='drone'){
      strokeFill('#32d37a','#0a552c',2); g.beginPath(); g.moveTo(x,y-16); g.lineTo(x+14,y); g.lineTo(x,y+16); g.lineTo(x-14,y); g.closePath(); g.fill(); g.stroke();
      strokeFill('#bff','#060',1.1); g.fillRect(x-4,y-4,8,8);
      return;
    }
    // ufo fallback
    strokeFill('#c9ccff','#444',2); g.beginPath(); g.ellipse(x,y,20,12,0,0,Math.PI*2); g.fill(); g.stroke();
    strokeFill('#8ff','#055',2); g.beginPath(); g.arc(x,y-8,9,0,Math.PI,true); g.fill(); g.stroke();
    strokeFill('#fff','#000',1); g.beginPath(); g.ellipse(x,y-6,3,5,0,0,Math.PI*2); g.fill(); g.stroke();
  }

  // Explosion system
  function spawnExplosion(x,y,kind='bullet'){
    const now = performance.now();
    explosions.push({x,y,kind,t:now,seed:Math.random()});
    if(actx){
      if(kind==='missile') sfxHeavyBoom();
      else sfxSmallBoom();
    }
  }
  function drawExplosions(now){
    for(const ex of explosions){
      const age = now - ex.t;
      const p = (ex.kind==='missile') ? (age/1200) : (age/600);
      if(p>=1) continue;
      if(ex.kind==='missile'){
        const r=24+80*(1-p), a=0.95*(1-p);
        const grd = g.createRadialGradient(ex.x,ex.y,0,ex.x,ex.y,r);
        grd.addColorStop(0, `rgba(255,255,120,${a})`);
        grd.addColorStop(0.35, `rgba(255,120,40,${a})`);
        grd.addColorStop(1, `rgba(40,10,10,0)`);
        g.fillStyle=grd; g.beginPath(); g.arc(ex.x,ex.y,r,0,Math.PI*2); g.fill();
        for(let i=0;i<8;i++){
          const ang = i*Math.PI*2/8 + ex.seed*6;
          const rr = r*0.4 + 50*(1-p);
          const x1 = ex.x + Math.cos(ang)*rr, y1 = ex.y + Math.sin(ang)*rr;
          strokeFill(`rgba(255,${120+Math.floor(80*Math.random())},0,${1-p})`,'#000',1);
          g.beginPath(); g.moveTo(ex.x,ex.y); g.lineTo(x1,y1); g.stroke();
        }
      } else {
        const count = 5 + Math.floor(ex.seed*6);
        for(let i=0;i<count;i++){
          const ang = i*Math.PI*2/count + ex.seed*10;
          const rr = 8 + 28*(1-p);
          const x1 = ex.x + Math.cos(ang)*rr, y1 = ex.y + Math.sin(ang)*rr;
          const mix = Math.random();
          const col = mix>0.5 ? `rgba(255,${140+Math.floor(60*Math.random())},0,${1-p})` : `rgba(255,${200+Math.floor(30*Math.random())},${40+Math.floor(20*Math.random())},${1-p})`;
          strokeFill(col,'#000',1);
          g.beginPath(); g.moveTo(ex.x,ex.y); g.lineTo(x1,y1); g.stroke();
        }
      }
    }
    explosions = explosions.filter(ex => {
      const max = (ex.kind==='missile')?1200:600;
      return performance.now() - ex.t < max;
    });
  }

  // Enemy shooting helpers
  function enemyFirePlasma(e){ const dx=player.x-e.x, dy=player.y-e.y; const mag=Math.max(20,Math.hypot(dx,dy)); const spd=110+Math.random()*40; enemyShots.push({type:'plasma', x:e.x, y:e.y+8, vx:dx/mag*spd, vy:dy/mag*spd, life:5000}); if(actx) sfxZap(); }
  function enemyFireLaserPulse(e){ const dx=player.x-e.x, dy=player.y-e.y; const mag=Math.max(20,Math.hypot(dx,dy)); const spd=420; enemyShots.push({type:'pulse', x:e.x, y:e.y+6, vx:dx/mag*spd, vy:dy/mag*spd, life:1400}); if(actx) sfxLaser(); }
  function enemyFireHoming(e){ const spd=82+Math.random()*30; enemyShots.push({type:'homing', x:e.x, y:e.y+10, vx:0, vy:spd, life:7000}); if(actx) sfxOrb(); }

  function updateEnemyShot(b,dt){
    if(b.type==='homing'){
      const tx=player.x, ty=player.y; const dx=tx-b.x, dy=ty-b.y; const mag=Math.max(20,Math.hypot(dx,dy));
      const desiredVx=dx/mag*120, desiredVy=dy/mag*120;
      b.vx += (desiredVx - (b.vx||0))*0.06; b.vy += (desiredVy - (b.vy||0))*0.06;
    }
    b.x += b.vx*dt; b.y += b.vy*dt; b.life -= dt*1000;
  }

  // Spawn waves
  function spawnWave(){
    const lvl = level;
    const count = 3 + Math.floor(Math.min(9, lvl/2));
    const spacing = innerWidth/(count+1);
    const shooterChance = Math.min(0.75, 0.08 + lvl*0.01);
    for(let i=0;i<count;i++){
      const p=Math.random(); let type='ufo';
      if(p>0.82) type='destroyer'; else if(p>0.60) type='frigate'; else if(p>0.42) type='drone'; else if(p>0.22) type='interceptor';
      const x=clamp(spacing*(i+1)+ri(-22,22),28,innerWidth-28); const y=-ri(20,420);
      const pattern=(Math.random()<0.25?1:(Math.random()<0.6?2:0));
      const willDive = Math.random() < Math.min(0.18, 0.04 + lvl*0.006);
      const spd = 16 + Math.random()*22 + lvl*0.7;
      const isElite = Math.random() < Math.min(0.09, lvl*0.007);
      const hp = (type==='destroyer'?3:(type==='frigate'?2:(isElite?2:1)));
      enemies.push({x,y,type,alive:true,spawnedAt:nowT(),deadAt:0,hp,pattern,phase:Math.random()*Math.PI*2,spd,wobble:Math.random()*22,dive:willDive,diveTimer:0, shooter:Math.random()<shooterChance, shotCd:1400+Math.random()*2600+lvl*40, elite:isElite});
    }
    nextWave = nowT() + clamp(Math.round(10000 - lvl*130), 1600, 12000);
  }

  // Centipede spawn & update - spacing tightened to 7, path cap 800, integer color cycling
  function spawnCentipede(lvl){
    const base = 6 + Math.floor(lvl/1.7);
    const segCount = Math.min(28, base + ri(0, Math.floor(lvl/2)));
    const qty = (lvl >= 6 ? (1 + Math.floor((lvl-4)/6)) : 1);
    for(let q=0;q<qty;q++){
      const head = { x: innerWidth/2 + (q - (qty-1)/2)*60, y: -40 - q*36, vy: 18 + Math.random()*6 + lvl*0.6, phase: Math.random()*Math.PI*2, amp: Math.max(120, Math.floor(innerWidth/2)-80) };
      const segSpacing = 7; // segments touch
      const path=[];
      for(let i=0;i<Math.ceil(segCount*segSpacing)+40;i++) path.push({x:head.x,y:head.y+i*2});
      const segments=[];
      for(let i=0;i<segCount;i++) segments.push({x:head.x,y:head.y - i*segSpacing, hp:1, index:i, colorIndex: i % CENT_COLORS.length});
      centipedes.push({segments, path, head, segSpacing, speed: 1 + lvl*0.02, alive:true, colorTick:0});
    }
  }

  function updateCentipedes(dt){
    for(let ci=centipedes.length-1; ci>=0; ci--){
      const cent = centipedes[ci];
      if(!cent.alive){ centipedes.splice(ci,1); continue; }
      cent.head.phase += dt * (1.2 + cent.speed*0.06);
      cent.head.x = innerWidth/2 + Math.sin(cent.head.phase) * cent.head.amp;
      cent.head.y += cent.head.vy * dt * 0.45 * (1 + (level-1)*0.03); // speed slightly up each round
      cent.path.push({x:cent.head.x, y:cent.head.y});
      const maxPath = 800;
      if(cent.path.length > maxPath) cent.path.splice(0, cent.path.length - maxPath);
      for(let s=0;s<cent.segments.length;s++){
        const targetIndex = Math.max(0, cent.path.length - 1 - s*cent.segSpacing);
        const p = cent.path[targetIndex] || cent.path[cent.path.length-1] || {x:cent.head.x,y:cent.head.y};
        cent.segments[s].x = p.x; cent.segments[s].y = p.y;
      }
      // color tick: increment integer every 60 frames
      cent.colorTick = (cent.colorTick || 0) + 1;
      if(cent.colorTick >= 60){
        for(const seg of cent.segments) seg.colorIndex = (seg.colorIndex + 1) % CENT_COLORS.length;
        cent.colorTick = 0;
      }
      // collision with player
      for(const seg of cent.segments){
        if(Math.abs(seg.x - player.x) < 18 && Math.abs(seg.y - player.y) < 20){
          spawnExplosion(player.x, player.y, 'bullet');
          lives = Math.max(0, lives-1); updateHUD();
          if(lives <= 0) return endGame();
        }
      }
      if(cent.head.y > innerHeight + 120){ cent.alive = false; centipedes.splice(ci,1); }
    }
  }

  function splitCentipede(ci, segIndex){
    const cent = centipedes[ci]; if(!cent) return;
    const left = cent.segments.slice(0, segIndex), right = cent.segments.slice(segIndex+1);
    const make = (arr) => { if(arr.length===0) return null; const newPath = cent.path.slice(); const newHead = {x:arr[0].x, y:arr[0].y-4, vy:cent.head.vy, phase:cent.head.phase, amp:cent.head.amp}; const newSegs = arr.map(s=>({x:s.x,y:s.y,hp:s.hp,colorIndex:s.colorIndex})); return {segments:newSegs, path:newPath, head:newHead, segSpacing:cent.segSpacing, speed:cent.speed*(0.95+Math.random()*0.2), alive:true}; };
    const L = make(left), R = make(right); centipedes.splice(ci,1); if(L) centipedes.push(L); if(R) centipedes.push(R);
  }

  // Specials
  function scheduleSpecials(reset=false){
    const t=nowT();
    if(reset || t>nextComet) nextComet = t + (30000 + Math.random()*50000);
    if(reset || t>nextMissilePickup) nextMissilePickup = t + (8000 + Math.random()*12000);
  }
  function spawnComet(){ specials.push({type:'comet', x: innerWidth+60, y: 80+Math.random()*120, vx:-160, vy:0, alive:true}); }
  function spawnMissilePickup(){ specials.push({type:'pickup', x:20+Math.random()*(innerWidth-40), y:-20, vx:0, vy:70+Math.random()*40, alive:true}); }

  // HUD
  function updateHUD(){ livesEl.innerHTML=''; for(let i=0;i<lives;i++){ const d=document.createElement('div'); d.className='life'; livesEl.appendChild(d);} scoreEl.textContent = `Score ${score} • Level ${level}`; ammoEl.textContent = `Missiles ${player.missileAmmo}`; }

  // Controls (tilt/joystick/keyboard)
  let useTilt=true, tiltAvailable=false, lastTiltEvent=0, tiltGamma=0, tiltBeta=0;
  function handleDeviceOrientation(e){ if(e && typeof e.gamma==='number'){ tiltGamma=e.gamma; tiltBeta=e.beta||0; lastTiltEvent=nowT(); tiltAvailable=true; } }
  async function requestTiltPermission(){ if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){ try{ const res = await DeviceOrientationEvent.requestPermission(); if(res==='granted') window.addEventListener('deviceorientation', handleDeviceOrientation); }catch(e){} } else window.addEventListener('deviceorientation', handleDeviceOrientation); }
  let joy={active:false,cx:0,cy:0,dx:0,dy:0,max:44};
  function resetStick(){ stickEl.style.transform='translate(0px,0px)'; joy.dx=joy.dy=0; }
  joystickEl.addEventListener('pointerdown',(ev)=>{ joystickEl.setPointerCapture(ev.pointerId); joy.active=true; const rect=joystickEl.getBoundingClientRect(); joy.cx=rect.left+rect.width/2; joy.cy=rect.top+rect.height/2; handleStickMove(ev.clientX, ev.clientY); hint.style.display='block'; setTimeout(()=>hint.style.display='none',900); },{passive:false});
  joystickEl.addEventListener('pointermove',(ev)=>{ if(!joy.active) return; handleStickMove(ev.clientX, ev.clientY); },{passive:false});
  joystickEl.addEventListener('pointerup',(ev)=>{ joy.active=false; resetStick(); try{ joystickEl.releasePointerCapture(ev.pointerId);}catch(e){} },{passive:false});
  function handleStickMove(cx,cy){ const dx=cx-joy.cx, dy=cy-joy.cy; const d=Math.sqrt(dx*dx+dy*dy); const max=joy.max; const scale=d>max?max/d:1; const sx=Math.round(dx*scale), sy=Math.round(dy*scale); joy.dx=sx/max; joy.dy=sy/max; stickEl.style.transform=`translate(${sx}px, ${sy}px)`; }

  addEventListener('keydown',(e)=>{ keys[e.code]=true; if(!running && (e.code==='Enter'||e.code==='Space')) start(); if(e.code==='Space'){ fireLaser(); e.preventDefault(); } if(e.code==='KeyM') fireMissile(); });
  addEventListener('keyup',(e)=>{ keys[e.code]=false; });
  laserBtn.addEventListener('pointerdown',(ev)=>{ laserBtn.setPointerCapture(ev.pointerId); fireLaser(); },{passive:true});
  laserBtn.addEventListener('pointerup',(ev)=>{ try{ laserBtn.releasePointerCapture(ev.pointerId);}catch(e){} },{passive:true});
  missileBtn.addEventListener('pointerdown',(ev)=>{ missileBtn.setPointerCapture(ev.pointerId); fireMissile(); },{passive:true});
  missileBtn.addEventListener('pointerup',(ev)=>{ try{ missileBtn.releasePointerCapture(ev.pointerId);}catch(e){} },{passive:true});

  // Weapons
  function fireLaser(){ if(!running) return; if(player.cd>0) return; player.cd=140; player.lasers.push({x:player.x, y:player.y-28, vy:-14, life:2200}); if(actx) sfxLaser(); }
  function fireMissile(){ if(!running) return; if(player.missileCd>0) return; if(player.missileAmmo<=0) return; player.missileAmmo--; player.missileCd=400; player.missiles.push({x:player.x, y:player.y-32, vy:-8, life:3500}); if(actx) makeNoiseBurst(0.12,0.08); updateHUD(); }

  // Collision helper
  function pointRect(px,py,rx,ry,rw,rh){ return !(px<rx||px>rx+rw||py<ry||py>ry+rh); }

  // Main loop
  last = performance.now();
  let lastCentipedeDeath = 0;
  function loop(){
    if(!running) return;
    const t = performance.now(), dt = Math.min(0.05,(t-last)/1000); last = t; frame++;
    const now = nowT();

    if(now - levelStart >= LEVEL_DURATION){ level++; levelStart = now; player.missileAmmo = Math.min(12, player.missileAmmo + 2); updateHUD(); }

    for(const s of stars){ s.y += s.spd * dt; if(s.y > innerHeight) s.y -= innerHeight; }

    const lvl = level;
    const baseSpeed = 8 + Math.min(6, Math.floor(lvl/2));
    const tiltIsRecent = (now - lastTiltEvent) < 1400;
    const canUseTilt = useTilt && tiltAvailable && tiltIsRecent;
    const anyKey = keys['ArrowLeft']||keys['ArrowRight']||keys['ArrowUp']||keys['ArrowDown']||keys['KeyA']||keys['KeyD']||keys['KeyW']||keys['KeyS'];
    if(anyKey) useTilt = false;
    if(joy.active){ player.x += joy.dx * baseSpeed * 1.6; player.y += joy.dy * baseSpeed * 0.8; }
    else if(canUseTilt){ const gx = clamp(tiltGamma,-45,45)/30; player.x += gx*(baseSpeed*1.2); player.y = clamp(player.y, innerHeight-160, innerHeight-30); }
    else { if(keys['ArrowLeft']||keys['KeyA']) player.x -= baseSpeed; if(keys['ArrowRight']||keys['KeyD']) player.x += baseSpeed; if(keys['ArrowUp']||keys['KeyW']) player.y -= baseSpeed*0.6; if(keys['ArrowDown']||keys['KeyS']) player.y += baseSpeed*0.6; }
    player.x = clamp(player.x,24,innerWidth-24); player.y = clamp(player.y, innerHeight-160, innerHeight-30);

    if(player.cd>0) player.cd -= dt*1000; if(player.missileCd>0) player.missileCd -= dt*1000;

    for(const L of player.lasers){ L.y += L.vy; L.life -= dt*1000; }
    for(const M of player.missiles){ M.y += M.vy; M.life -= dt*1000; }
    player.lasers = player.lasers.filter(l => l.life > 0 && l.y > -40);
    player.missiles = player.missiles.filter(m => m.life > 0 && m.y > -40);

    if(now > nextWave) spawnWave();
    if(now > nextMissilePickup){ spawnMissilePickup(); scheduleSpecials(); }
    if(now > nextComet){ spawnComet(); scheduleSpecials(); }

    updateCentipedes(dt);

    if (centipedes.length === 0 && now - lastCentipedeDeath > 1000) {
      spawnCentipede(level);
      lastCentipedeDeath = now;
    }

    for(const e of enemies){
      if(!e.alive){ if(!e.deadAt) e.deadAt = now; continue; }
      if(!e.spawnedAt) e.spawnedAt = now;
      e.age = now - e.spawnedAt;
      if(e.dive && e.diveTimer <= 0 && Math.random() < 0.003){ e.diveTimer = 600 + Math.random()*1000; e.targetPhase = Math.random(); }
      if(e.dive && e.diveTimer > 0){
        e.diveTimer -= dt*1000;
        const dx = (player.x - e.x), dy = (player.y - e.y);
        const dist = Math.max(20, Math.hypot(dx,dy));
        const vx = dx/dist * (80 + Math.random()*40 + lvl*3);
        const vy = dy/dist * (80 + Math.random()*40 + lvl*2.5);
        e.x += vx * dt; e.y += vy * dt;
      } else {
        if(e.pattern === 0){
          e.x += Math.sin(e.age*0.004 + e.phase) * (8 + (e.wobble||0)) * dt;
          e.y += e.spd * dt;
        } else if(e.pattern === 1){
          e.x += Math.sin((e.age*0.006) + e.phase) * (24 + lvl*2) * dt;
          e.y += e.spd * dt;
        } else {
          e.phase += (Math.random()-0.5)*0.3;
          e.x += Math.sin(e.age*0.012 + e.phase) * (18 + Math.random()*18) * dt;
          e.y += (e.spd*0.7 + Math.random()*16 + lvl*0.6) * dt;
        }
      }
      if(e.alive && e.y > innerHeight - 10){ e.alive=false; e.deadAt=now; spawnExplosion(e.x,e.y,'bullet'); lives = Math.max(0,lives-1); updateHUD(); if(lives<=0) return endGame(); }

      if(e.shooter && e.alive){
        e.shotCd = (e.shotCd || (1600 + Math.random()*2400)) - dt*1000;
        if(e.shotCd <= 0){
          if(e.type === 'interceptor'){ enemyFirePlasma(e); setTimeout(()=>{ if(e.alive) enemyFirePlasma(e); }, 90); }
          else if(e.type === 'destroyer'){ enemyFireLaserPulse(e); }
          else if(e.type === 'drone'){ if(Math.random()<0.45) enemyFireHoming(e); else enemyFirePlasma(e); }
          else { enemyFirePlasma(e); }
          e.shotCd = Math.max(500, 900 + Math.random()*1400 + lvl*20);
        }
      }
    }

    for(const s of specials){ s.x += (s.vx||0)*dt; s.y += (s.vy||0)*dt; }

    // collisions: lasers
    for(const L of player.lasers){
      for(const e of enemies){
        if(!e.alive) continue;
        if(Math.abs(L.x - e.x) < 18 && Math.abs(L.y - e.y) < 16){
          e.hp -= 1; L.life = -1; spawnExplosion(e.x,e.y,'bullet');
          if(e.hp <= 0){ e.alive=false; e.deadAt=now; spawnExplosion(e.x,e.y,'missile'); score += 10 + (e.elite?40:0); updateHUD(); }
        }
      }
      for(let ci=centipedes.length-1; ci>=0; ci--){
        const cent = centipedes[ci];
        for(let si=0; si<cent.segments.length; si++){
          const seg = cent.segments[si];
          if(Math.abs(L.x - seg.x) < 14 && Math.abs(L.y - seg.y) < 12){
            spawnExplosion(seg.x, seg.y, 'missile'); score += 8; L.life = -1; splitCentipede(ci, si); break;
          }
        }
      }
      for(const s of specials){
        if(!s.alive) continue;
        if(Math.abs(L.x - s.x) < 18 && Math.abs(L.y - s.y) < 18){
          if(s.type === 'pickup'){ player.missileAmmo = Math.min(12, player.missileAmmo + 3); if(actx) makeOsc(1100,'triangle',0.06,0.06); updateHUD(); }
          else if(s.type === 'comet'){ lives = Math.min(6, lives+1); if(actx) makeNoiseBurst(0.24,0.12); updateHUD(); }
          s.alive = false; L.life = -1;
        }
      }
    }

    // missiles collisions
    for(const M of player.missiles){
      for(const e of enemies){
        if(!e.alive) continue;
        if(Math.abs(M.x - e.x) < 26 && Math.abs(M.y - e.y) < 22){
          e.hp -= 2; M.life = -1;
          if(e.hp <= 0){ e.alive=false; e.deadAt=now; spawnExplosion(e.x,e.y,'missile'); if(actx) sfxHeavyBoom(); score += 22 + (e.elite?60:0); updateHUD(); }
        }
      }
      for(let ci=centipedes.length-1; ci>=0; ci--){
        const cent = centipedes[ci];
        for(let si=0; si<cent.segments.length; si++){
          const seg = cent.segments[si];
          if(Math.abs(M.x - seg.x) < 20 && Math.abs(M.y - seg.y) < 18){
            spawnExplosion(seg.x, seg.y, 'missile'); score += 12; M.life = -1; splitCentipede(ci, si); si = cent.segments.length; break;
          }
        }
      }
      for(const s of specials){
        if(!s.alive) continue;
        if(Math.abs(M.x - s.x) < 26 && Math.abs(M.y - s.y) < 26){
          if(s.type === 'pickup'){ player.missileAmmo = Math.min(12, player.missileAmmo + 3); updateHUD(); }
          else if(s.type === 'comet'){ lives = Math.min(6, lives+1); updateHUD(); }
          s.alive = false; M.life = -1; spawnExplosion(s.x,s.y,'missile'); if(actx) sfxHeavyBoom();
        }
      }
    }

    for(const b of enemyShots) updateEnemyShot(b, dt);
    for(const b of enemyShots){
      if(Math.abs(b.x - player.x) < 18 && Math.abs(b.y - player.y) < 20){
        b.life = -1; spawnExplosion(player.x, player.y, 'bullet'); lives = Math.max(0, lives-1); updateHUD(); if(lives <= 0) return endGame();
      }
    }

    for(let i=player.lasers.length-1;i>=0;i--){
      const L = player.lasers[i];
      for(let j=enemyShots.length-1;j>=0;j--){
        const b = enemyShots[j];
        if(Math.abs(L.x - b.x) < 10 && Math.abs(L.y - b.y) < 10){
          spawnExplosion(b.x,b.y,'bullet'); L.life = -1; b.life = -1; if(actx) sfxSmallBoom(); score += 1; updateHUD(); break;
        }
      }
    }
    for(let i=player.missiles.length-1;i>=0;i--){
      const M = player.missiles[i];
      for(let j=enemyShots.length-1;j>=0;j--){
        const b = enemyShots[j];
        if(Math.abs(M.x - b.x) < 18 && Math.abs(M.y - b.y) < 18){
          spawnExplosion(b.x,b.y,'missile'); M.life = -1; b.life = -1; if(actx) sfxHeavyBoom(); score += 2; updateHUD(); break;
        }
      }
    }

    for(const s of specials){
      if(!s.alive) continue;
      if(s.type === 'pickup' && Math.abs(s.x - player.x) < 32 && Math.abs(s.y - player.y) < 32){
        player.missileAmmo = Math.min(12, player.missileAmmo + 3); s.alive = false; if(actx) makeOsc(1400,'triangle',0.06,0.06); updateHUD();
      }
    }

    for(let i=specials.length-1;i>=0;i--){ const s=specials[i]; if(!s.alive || s.x < -140 || s.x > innerWidth+120 || s.y > innerHeight+120) specials.splice(i,1); }
    for(let i=enemyShots.length-1;i>=0;i--){ const b=enemyShots[i]; if(b.life<=0 || b.y>innerHeight+80 || b.x<-80 || b.x>innerWidth+80) enemyShots.splice(i,1); }
    for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; if(!e.alive && e.deadAt && (now - e.deadAt) > 700) enemies.splice(i,1); }

    drawFrame();
    requestAnimationFrame(loop);
  }

  function drawFrame(){
    const now = nowT();
    g.clearRect(0,0,innerWidth,innerHeight);
    // stars
    g.fillStyle = '#fff'; for(const s of stars) g.fillRect(s.x,s.y,s.s,s.s);

    // specials
    for(const s of specials){
      if(!s.alive) continue;
      if(s.type === 'pickup'){
        // static mini missile - brighter
        strokeFill('#ffffff','#7a5200',2); g.beginPath(); g.rect(s.x-12,s.y-8,24,16); g.fill(); g.stroke();
        // nose
        strokeFill('#ff4b4b','#000',1); g.beginPath(); g.moveTo(s.x+12,s.y); g.lineTo(s.x+18,s.y-6); g.lineTo(s.x+18,s.y+6); g.closePath(); g.fill(); g.stroke();
        // fins
        strokeFill('#333','#000',1); g.beginPath(); g.moveTo(s.x-12,s.y-8); g.lineTo(s.x-18,s.y-12); g.lineTo(s.x-12,s.y); g.closePath(); g.fill();
        g.fillStyle='#000'; g.font='700 12px Arial'; g.textAlign='center'; g.fillText('M', s.x, s.y+4);
      } else if(s.type === 'comet'){
        strokeFill('#ffcc5c','#5a1a00',2); g.beginPath(); g.arc(s.x,s.y,12,0,Math.PI*2); g.fill(); g.stroke();
        strokeFill('rgba(255,204,92,0.26)','rgba(0,0,0,0)',1); g.beginPath(); g.moveTo(s.x-28,s.y); g.lineTo(s.x-50,s.y-8); g.lineTo(s.x-50,s.y+8); g.closePath(); g.fill();
        g.fillStyle='#fff'; g.font='700 12px Arial'; g.textAlign='center'; g.fillText('★', s.x, s.y+2);
      }
    }

    // centipedes
    for(const cent of centipedes){
      for(const seg of cent.segments){
        const col = CENT_COLORS[Math.floor(seg.colorIndex) % CENT_COLORS.length];
        strokeFill(col,'#111',1.6); g.beginPath(); g.ellipse(seg.x, seg.y, 10, 8, 0, 0, Math.PI*2); g.fill(); g.stroke();
        strokeFill('#fff','#000',1); g.fillRect(seg.x-3, seg.y-2, 6, 4);
      }
    }

    // enemies
    for(const e of enemies){
      if(e.alive) drawEnemy(e.x,e.y,e.type,e.elite,frame);
      else {
        // small dying burst
        spawnExplosion(e.x,e.y,'bullet');
      }
    }

    // enemy shots
    for(const b of enemyShots){
      if(b.type==='plasma'){ strokeFill('#ff6b6b','#400',1.2); g.beginPath(); g.arc(b.x,b.y,4,0,Math.PI*2); g.fill(); g.stroke(); }
      else if(b.type==='pulse'){ strokeFill('#9ff4ff','#052',1.2); g.fillRect(b.x-2,b.y-18,6,36); }
      else if(b.type==='homing'){ strokeFill('#7dff8a','#063',1.2); g.beginPath(); g.ellipse(b.x,b.y,6,6,0,0,Math.PI*2); g.fill(); g.stroke(); }
    }

    // explosions
    drawExplosions(nowT());

    // player
    drawPlayer(player.x, player.y, frame);
    for(const L of player.lasers){ strokeFill('#aef','#114',1.2); g.fillRect(L.x-2, L.y-12, 4, 14); }
    for(const M of player.missiles){ strokeFill('#fff8d0','#5a3d00',1.2); g.beginPath(); g.ellipse(M.x, M.y, 8, 14, 0, 0, Math.PI*2); g.fill(); g.stroke(); }

    // HUD drawn via DOM
  }

  // Start / end
  function start(){
    ensureAudio(); resumeAudio(); sfxStart();
    startMusic();
    running=true;
    player={ x:innerWidth/2, y:innerHeight-70, lasers:[], missiles:[], missileAmmo:8, cd:0, missileCd:0 };
    score=0; lives=3; enemies=[]; specials=[]; explosions=[]; enemyShots=[]; centipedes=[];
    level=1; levelStart=nowT(); lastCentipedeDeath = nowT();
    updateHUD(); scheduleSpecials(true); spawnWave(); spawnCentipede(1);
    splash.style.display='none'; hud.style.display='flex'; controlsEl.style.display='flex'; toggle.style.display='block';
    toggle.textContent = `Controls: ${useTilt?'Tilt':'Touch'}`;
    requestTiltPermission().catch(()=>{});
    last = performance.now(); loop();
  }
  function endGame(){ running=false; stopMusic(); finalScore.textContent=`Score: ${score}`; gameover.style.display='flex'; hud.style.display='none'; controlsEl.style.display='none'; toggle.style.display='none'; }

  // UI wiring
  startBtn.addEventListener('click', ()=>start(), {passive:true});
  restartBtn.addEventListener('click', ()=>{ gameover.style.display='none'; splash.style.display='flex'; });
  instrBtn.addEventListener('click', ()=>{ alert('Tilt your phone to move (or use the joystick). Tap FIRE to shoot lasers. Tap M to fire missiles if you have ammo. Comets give extra lives.'); }, {passive:true});
  toggle.addEventListener('click', ()=>{ useTilt=!useTilt; toggle.textContent=`Controls: ${useTilt?'Tilt':'Touch'}`; hint.style.display='block'; setTimeout(()=>hint.style.display='none',1500); });

  // initial timers
  scheduleSpecials(true);
  nextMissilePickup = nowT() + 1200;
  nextComet = nowT() + (30000 + Math.random()*60000);
  nextWave = nowT() + 3500;

  // prevent context menu
  addEventListener('contextmenu', e=>e.preventDefault());

  // expose debug
  window.__game = { start, endGame, spawnWave, spawnCentipede, getState: ()=>({score,lives,player,enemies,specials,enemyShots,centipedes,level}) };

})();
</script>
</body>
</html>

